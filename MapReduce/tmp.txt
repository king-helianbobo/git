序列化是将结构化的对象状态转换为可持久性或传输的字节流格式的过程，与序列化相对的是反序列化，它将字节流转换为一系列结构化的对象。这两个过程相结合，可实现轻松自如地存储和传输数据。

序列化的目的有两个：一是以某种存储形式使自定义对象持久化；二是将对象从一个地方传递到另一个地方。 通常有两种序列化技术：二进制序列化和XML序列化。二进制序列化保持类型保真度，这对于在应用程序的不同调用之间保留对象的状态很有用。例如，通过将对象序列化到剪贴板，可在不同的应用程序之间共享对象。您可以将对象序列化到流、磁盘、内存和网络等等。远程处理使用序列化“通过值”在计算机或应用程序域之间传递对象。
XML序列化仅序列化公共属性和字段，且不保持类型保真度。当要提供或使用数据而不限制使用该数据的应用程序时，这一点是很有用的。由于XML是一个开放式标准，因此，对于通过Web共享数据而言，这是一个很好的选择。


初级：熟悉基本语法，熟练掌握编译，链接，执行和调试过程，能够指出任意一段代码可能存在的错误或不符合标准之处。
中级：清楚常见的c语言编译器如TC、VC、BCC、LCC、C51、VDSP和GCC的语法差异以及移植可能带来的问题。
高级：在代码行数达到十万行的程序里，若程序崩溃，能在一小时内定位问题。
清楚如何避免c程序在不同操作系统间移植带来的问题，清楚编译器如何防止CPU缺陷，清楚如何改进编译器生成的代码。


初级：熟悉基本语法，能在宿主语言中调用脚本语言，熟练掌握编写，运行和调试过程，能够指出任意一段代码可能存在的错误或不符合标准之处。
中级：清楚脚本语言在操作系统层，应用程序层和高级编程语言层之间交叉使用的优势与不足，以及如何发挥脚本语言优势，避免在不足之处使用脚本语言。
高级：能针对特定应用程序，优化脚本语言解释器



在这种情况下，这种模式可极大简化并行编程，




MapReduce模型可将用户需要处理的工作分解为两个功能模块Map和Reduce，用户通过指定的Map函数对输入的数据进行切分，产生一系列中间键值对；MapReduce底层实现将所有具有相同键值的键值对合并到一起，并传递给Reduce函数；用户通过指定的Reduce函数处理得到的一系列键值相同的中间结果对，
（1）
（2）


针对需求分析，MapReduce产品需实现如下功能：
（1）简化复杂的数据处理计算过程：为简化复杂的数据处理过程，MapReduce模型将数据处理过程分为两个阶段，即map阶段和reduce阶段，每个阶段都将一系列key/value对作为输入和输出，其中的键和值的类型为MapReduce软件产品的用户指定。同时，用户指定map函数和reduce函数。
根据用户指定的map函数，接受一个输入key/value对，然后产生一系列临时中间key/value对。根据用户指定的reduce函数，接受一个中间key和相关的一个value集。它合并这些value，形成一个比较小的value集合。通常，每次reduce调用只输出1个value。
（2）分割输入数据：根据用户定义的map任务数量，生成若干个map任务，每一个map任务负责将一部分输入数据转换成一系列中间key/value对；
（3）在大规模集群上执行调度：执行调度即任务分配问题，为避免网络流量激增或某些任务服务器负载过重导致效率下降，需要将合适作业的合适任务分配到合适的服务器上，涉及两个步骤，先选择作业，然后在此作业中选择任务；
（4）合并中间结果：当所有map任务完成后，执行reduce任务，它负责到执行过map任务的任务服务器上收集中间结果，并计算出最终结果；
（5）具备三种故障处理功能：（a）任务失败时，由于用户自定义的代码可能有bug，错误本身无法修复，记录错误发生点到日志，并将错误报告发送给作业主节点；（b）任务节点故障处理，当任务节点故障时，将所有原本分配给这个任务节点的任务安排给其它的任务节点；（c）作业主节点故障处理，一旦作业主节点故障，立即启动作业主节点的备用机器，该机器将作为集群中作业主节点。


由于
将，这里面蕴含了两个步骤，和所
有分配工作一样，任务分配也是一个复杂的活。不良好的任务分配，可能会导致网
络流量增加、某些任务服务器负载过重效率下降，等等。不仅如此，任务分配还是
一个无一致模式的问题，不同的业务背景，可能需要不同的算法才能满足需求。关
任务调度将在下一章进行详细地论述，在此就不赘述了。
当用户提交一个作业到作业服务器上，作业服务器会，每一
个 Map 任务，负责将一部分的输入转换成格式与最终格式相同的中间文件。通常一
个作业的输入都是基于分布式文件系统的文件，因为它可以很天然的和分布式的计
算产生联系。





管理集群内机器之间必要的通信


管理集群内机器的错误处理

以这种函数式编写的程序能自动的在大规模的普通机器上并行的执行。我们设计基于MapReduce模型的分布式系统时要特别关注以下细节：分割输入数据；；机器；。这样就允许系统用户在没有任何并行或分布式系统经验的情况下容易地利用大量分布式系统的
资源。下面将列举描述这个模型实际如何工作。










数据库知识：SQL结构化查询语言掌握程度，能熟练掌握涉及多表的复杂查询。了解关系对象模型，对象数据库和XML数据库。能描述事务一致性、隔离性、原子性与持久性，了解平坦事务与多级事务以及存储点，能针对应用程序访问特点，选择SQL隔离级别。了解基于日志的数据库故障恢复策略。
数据库设计：数据库约束条件编写，实现数据库管理系统（Oracel，MySQL，SQLServer）触发器。掌握ER设计方法，能设计面向业务的实体联系模型、能使用关系规范化理论评价ER设计。了解常用数据库索引（如B树索引、哈希索引，T树索引等），并针对查询进行索引设计，能优化SQL查询语句。
数据库使用：在宿主语言（C,Java等）中能熟练使用JDBC、ODBC。能编写面向特定数据库管理系统的存储过程。能使用JPA、Hibernate实现对象与数据库表映射。在分布式环境下能实现数据库分段策略、多站点数据库复制实现以及多个站点上数据库的联合查询策略。












4.3.2worker节点故障处理
Worker节点故障是很容易获知的。因为master周期性的ping每个worker节点，
一旦master在一个有效的时间段内没有收到worker传回的心跳包，那么它将把这
个worker的状态标记为失效。一个worker节点失效后，所有原本分配给这个worker
完成的map任务都会被重置为初始idel状态，这样就可以安排给其他的workers来
完成。与此同时，所有在失败的worker上正在运行的map或reduce任务，也都会
被重置为idle状态。
当一个map任务由于worker节点故障而重新分配给其他workerA节点后，所
有执行reduce任务的worker都会被通知。所有还没有得及从原始失败节点上读取数
据的worker都会从A上读取数据。
MapReduce可以有效地支持到很大尺度的worker失效的情况。在一个
MapReduce操作期间，如果正在运行的机群上进行由于某些原因导致一些机器故障，
MapReducemaster只是简单的再次执行那些workers完成的工作，最终完成这个
MapReduce操作。
4.3.3master故障处理
4.3.4防止错误的其他策略
分布式文件系统kiddenfs被设计能够在一个大集群中跨机器可靠地存储超大文
件。它将每个文件在逻辑上存储成一系列的数据块，除了最后一个，所有其他数据
块都是同样大小的。为了容错，文件的所有数据都应该保留多个副本。每个文件的
数据块大小和副本系数都是可配置的。
副本的存放是kiddenfs可靠性和性能的关键。我们将副本存放在不同的机架上。
这样可以有效地防止当整个机架失效时数据的丢失，并且允许读数据的时候充分多
个的带宽。这种策略设置可以将副本均匀分布在集群中，有利于当组件失效情况下
的负载均衡。但是，因为这种策略的一个写操作需要传输数据块到多个机架，这增
加了写的代价。相比优点而言，这点代价完全是值得的。
当系统任务运行需要访问这些数据时，为了降低整体的带宽消耗和读取延时，
系统会尽量让读取程序读取离它最近的副本。如果在读取程序的同一个机架上有一
个副本，那么就读取该副本。如果一个集群跨越多个数据中心，那么客户端也将首
先读本地中心的副本。


