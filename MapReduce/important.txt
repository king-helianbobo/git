3、JobQueueTaskScheduler会为每个TaskTracker预留少量的计算能力，专为最高优先级的Job服务（也就是jobQueue中第一个能够分派任务的Job）。如果当前TaskTracker用完了非预留的计算能力，则最多只会分派一个任务（当然，分派的任务一定属于最高优先级的Job，因为分派过程是按Job的优先级顺序来进行的）；
break之后，本次分派的任务可能就填不满TaskTracker的空闲Slot了，不过没关系，等这个TaskTracker下一次来心跳的时候，JobTracker又会再给它分派任务。这样的设计使得：
1、Map任务趋于分派到更合适的TaskTracker上。如果没有合适的Map任务分派给当前TaskTracker，则延迟其他Map任务的分派。那么这些延迟分派的Map任务可能可以分派到其他更合适的TaskTracker上；
2、Reduce任务趋于平均分派到每一个TaskTracker上。因为每个TaskTracker每次心跳都最多领走一个Reduce任务，只要每个TaskTracker心跳的频率相当，Reduce任务就能平均分派；
3.在这一步Job初始化完成之后，Job下的Task才能被分派给TaskTracker。（然后，首先只能分派一个Setup任务，并且等它执行完成之后，其他的Map和Reduce任务才能被分派，见《Hadoop OutputFormat浅析》。）
EagerTaskInitializationListener完成了对Job的初始化，很多TaskScheduler都会使用到它。
此外，在EagerTaskInitializationListener中，提交给工作线程初始化的Job会先放到一个按优先级排序的Queue里面，同样是以priority为第一排序因子、以startTime为第二排序因子。然后jobUpdated()会根据Job的priority或startTime的变化来调整Job在Queue中的排序；而jobRemoved()则会将Job从Queue中移除。
不过这里的优先级其实作用不是很大，因为相比于Job的执行时间，Job的初始化时间基本上可以忽略不计。（Job在Queue中发生竞争的可能性不大。）
