\section{联机分析处理}
\subsection{OLAP相关概念（联机分析处理）}
\par Mondrian是一个基于Java语言的开源OLAP引擎，它通过MDX语句执行查询，从关系型数据库RDBMS中读取数据，以多维度的形式展示查询结果。
\par Mondrian通过Schema来定义一个多维数据库，它是一个逻辑概念上的模型，其中包含Cube（立方体）、Dimension（维度）、Hierarchy（层次）、Level（级别）、Measure（度量），这些被映射到数据库物理模型。Mondrian中Schema是以XML文件的形式定义的。
\begin{itemize}
\item Cube（立方体）是一系列Dimension和Measure的集合区域，它们共用一个事实表。
\item Dimension（维度）是一个Hierarchy的集合，维度一般有其相对应的维度表，它由Hierarchy（层次）组成，而Hierarchy（层次）又是由组成Level（级别）的。
\item Hierarchy（层次）是指定维度的层级关系的，如果没有指定，默认Hierarchy里面装的是来自立方体中的真实表。
\item Level（级别）是Hierarchy的组成部分，使用它可以构成一个结构树，Level的先后顺序决定了Level在结构树上的位置，最顶层的 Level 位于树的第一级，依次类推。
\item Measure（度量）是我们要进行度量计算的数值，支持的操作有sum、count、avg、distinct-count、max、min等。
\end{itemize}
\par 概括总结一下：在多维分析中，关注的内容通常被称为度量(Measure)，而把限制条件称为维度(Dimension)。多维分析就是对同时满足多种限制条件的所有度量值做汇总统计。包含度量值的表被称为事实表(Fact Table)，描述维度具体信息的表被称为维表(Dimension Table)，同时有一点需要注意：并不是所有的维度都要有维表，对于取值简单的维度，可以直接使用事实表中的一列作为维度展示。
\par 下面是Mondrian中一个简单的Schema文件,其中包含一个名为“Sales”的Cube，立方体中有两个维度：“Gender”和“Time”，两个度量值：“Unit Sales”和“Store Sales”。
\begin{verbatim}
<Schema>
<Cube name="Sales">
<Table name="sales_fact_1997"/>
<Dimension name="Gender" foreignKey="customer_id">
<Hierarchy hasAll="true" allMemberName="All Genders" primaryKey="customer_id">
<Table name="customer"/>
<Level name="Gender" column="gender" uniqueMembers="true"/>
</Hierarchy>
</Dimension>
<Dimension name="Time" foreignKey="time_id">
<Hierarchy hasAll="false" primaryKey="time_id">
<Table name="time_by_day"/>
<Level name="Year" column="the_year" type="Numeric" uniqueMembers="true"/>
<Level name="Quarter" column="quarter" uniqueMembers="false"/>
<Level name="Month" column="month_of_year" type="Numeric" uniqueMembers="false"/>
</Hierarchy>
</Dimension>
<Measure name="Unit Sales" column="unit_sales" aggregator="sum" formatString="#,###"/>
<Measure name="Store Sales" column="store_sales" aggregator="sum" formatString="#,###.##"/>
<Measure name="Store Cost" column="store_cost" aggregator="sum" formatString="#,###.00"/>
<CalculatedMember name="Profit" dimension="Measures" formula="[Measures].[Store Sales] - [Measures].[Store Cost]">
<CalculatedMemberProperty name="FORMAT_STRING" value="$#,##0.00"/>
</CalculatedMember>
</Cube>
</Schema>
\end{verbatim}
\subsection{数据预处理}
\par 不正确，不完整和不一致的数据是商场中数据的普遍特点，如许多数据库表元组在某些属性上根本没有值，有些期望获得的属性没有被记录，对同一款商品，不同商场的命名不一样。当用户不希望暴露个人信息的时候，可能故意输入不正确的生日日期。对一个大型商场而言，某个用户的家庭住址可能早就过期了，但针对不同的数据挖掘任务，其满意度也不同，销售人员不太满意，但市场分析人员对这个家庭住址就不太看重。
\begin{itemize}
\item 数据清理用来清除数据中的噪声，纠正不一致。数据清理通过填写缺失的值，光滑噪声数据，识别或删除离群点，也就是清除脏数据的过程，脏数据可能会使某些挖掘算法陷入混乱，导致不可靠的输出。ETL（Etractrion,Transform，Loading）工具允许用户说明简单的变换，如将字符串“列宁格勒”用“圣彼得堡”代替。
\item 数据集成将数据由多个数据源合并成一个一致的数据存储，如数据仓库。代表同一概念的属性在不同的数据库中可能具有不同的名字，关于顾客标识的属性在一个商场数据库中是\textsl{customer\_id},而在另一个数据库中为\textsl{cust\_id},命名的不一致还可能出现在属性值中，例如，方便面在第一个数据库中登记为\textbf{方便面}，在第二个数据库中登记为\textbf{泡面}，在第三个数据库中登记为\textbf{速食面}，某些属性值可能是由其它属性值导出的，例如选修某课程的人数。
\item 数据归约可以通过聚集，删除冗余特征或者聚类方法来降低数据的规模，得到数据的简化表示，小很多，但能产生同样的分析结果。经常用的方法有：小波变换，主成分分析，属性子集选择（去掉不相关的属性）和属性构造（从原来的属性集中生成更有用的小属性集），使用参数模型（回归和对数线性模型）或非参数模型（直方图，聚类，抽样）等。
\item 数据变换可以用来把数据压缩到较小的空间，如0.0到1.0，可以提高涉及距离度量的挖掘算法的准确率和效率。例如，涉及诸如神经网络，最近邻分类或聚类这样的基于距离的挖掘算法。对不同的属性，例如年龄和年薪，年薪的取值范围远远大于年龄，因此，属性值必须规范化。同样的，数据必须进行概念分层，属性的原始值被区间或更高层的概念取代，年龄的原始值可以用较高层的概念（如少年，青年，壮年，老年）取代。
\end{itemize}
\subsection{数据变换与数据离散化}
\par 数据必须变换成统一格式，使得数据挖掘过程更加有效，数据变换策略包括如下几种：
\begin{enumerate}[(1)]
\item 光滑，去掉数据中的噪音，包括分箱，回归和聚类，
\item 属性构造，可以由给定的属性构造出新的属性，并添加到属性集中，
\item 聚集，对数据进行汇总，例如，可以聚集日销售数据，计算每月和每年的销售量，这一步用来为多个抽象层的数据分析构造数据立方体。
\item 规范化，把属性数据按比例缩放，使其落入一个特定的小区间，如$[-1.0 \sim 1.0]$内
\item 离散化：数值属性的原始值（例如年龄）用区间标签（例如，$[0 \sim 10]$，$[11 \sim 20]$，$\cdots$）或概念标签（\textbf{年轻}，\textbf{成熟}，\textbf{老者}）代替，这些概念标签能进一步组成概念分层，即属性的扩展。
\item 由标称数据产生概念分层：属性，如\textbf{街道}，可以泛化到较高的概念层，如\textbf{城市}，\textbf{省份},\textbf{国家}等
\end{enumerate}
\subsection{数据仓库与数据挖掘}
\par 为设计有效的数据仓库，必须理解和分析商务需求，并构造一个商务分析框架。建立数据仓库的关键有：如何构造一个提取程序，将数据由商场中的操作数据库转换到数据仓库;如何构造一个仓库刷新软件，合理地保持数据仓库相对于当前商场数据库的实时性，即数据应保持尽可能的同步。
\begin{enumerate}[(1)]
\item 选取多个待建模的主题，以主题为中心，构造数据集市（以星形模式构建主题）;
\item 选取处理的粒度，在事实表中是数据的原子级（例如，单个事务，数据库一天的快照）;
\item 选取用于每个事实表记录的维，典型的维包括时间，商品，顾客，供应商，仓库，事务类型和状态;
\item 选取将安装在每个事实表记录中的度量，典型的度量（measure）函数有count()，sum()，min()，max()等。
\end{enumerate}
\par 最初，数据仓库主要用于产生报告和预先定义的查询，渐渐地，它用于分析汇总和详细数据，结果以报表和图标形式提供，稍后，数据挖掘用于决策，进行多维分析和复杂的切片与切块操作，最后，使用数据挖掘，数据仓库可用于知识发现。因此，定义在数据仓库上的工具包括：访问与检索工具，数据库报表工具，数据分析工具和数据挖掘工具。一般来说，数据仓库的应用，进化步骤如下：\framebox{信息处理}$\longrightarrow$\framebox{分析处理}$\longrightarrow$\framebox{数据挖掘}，其中信息处理支持查询和基本的统计分析，并使用表或图进行报告，分析处理支持数据仓库的多维数据分析，数据挖掘支持知识发现，包括找出隐藏的模式和关联，构造分析模型，进行分类和预测。
\par 数据挖掘比OLAP的功能要广泛许多，OLAP的目标是简化和支持交互数据分析，是用户指导下的汇总和比较，而数据挖掘不仅执行数据汇总和比较，也执行关联，分类，预测，聚类，时间序列分析和其它数据分析任务。数据仓库包含海量数据，OLAP服务器要在数秒内回答决策支持查询，数据仓库系统要支持高效的数据立方体计算技术，存取方法和查询处理技术。
\subsection{数据同步}
数据同步：当数据源发生改变时，其他相关数据也跟着发展变化。根据需求不同可采取以下方案。
\begin{itemize}
\item 触发器：在数据库建立增删改的触发器。触发器将变更放到一张临时表里。其优点在于：实时同步，缺点：影响到业务系统，因为需要在业务系统建立触发器。
\item 日志：通过分析源数据库日志，来获得源数据库中的变化的数据。优点：不影响业务系统，缺点：有一定延时，对于没有提供日志分析接口的数据源，开发的难度比较大。对商品这类的表，数据量比较大（有无用于描述商品入库时间的属性列，如果有，就有了时间戳信息），而且很可能没有时间戳。
\par \qquad 目前对于业务数据库实时同步到数据仓库中，最简单的方案是给业务数据库增加一个从(Slave)数据库，从数据库一般通过读取主数据库的OpLog（记录了每一次数据变化的操作），来和主(Master)数据库来保持数据的一致性，并且不会对主数据库造成很大的性能影响。最简单的，我们可以通过每分钟对从数据库的新增数据进行一次扫描读取，来传输到数据仓库中，因为业务系统是不连接从数据库的，所以这不会对业务系统造成影响。既然读取主数据库的OpLog便可以在不大影响性能的情况下保持数据的准实时同步，那么我们为什么还需要一个从数据库呢？这确实是解决问题的一个思路，不过解析OpLog相对于直接SQL查询从数据库来说更加困难，开发成本较高。腾讯的TDBank数据仓库系统中，采用了类似的方案，他们开发了MyDbSync软件，通过解析MySQL的binlog（也就是OpLog）来同步数据，取得了良好的使用效果。 
\item 时间戳：在要同步的源表里有时间戳字段，每当数据发生变化，时间戳会记录发生变化的时间，设置一个限制，只提取最近一段时间以来添加的数据。Sqoop是Hadoop生态圈的工具，支持渐进式的，将关系数据库内容导入到hdfs，或将hdfs数据导入到关系数据库中，提供了基于某个列的时间戳或ID大小，来导入最近添加（修改）的行到hdfs中。商场数据库中，对于用户的一次购买活动，描述这个购买活动记录的应该有时间戳信息，可以用这个信息，来同步与用户购买活动相关的表。
\item 数据比较：通过比较两边数据源数据，来完成数据同步。一般用于实时性要求不高的场景。假如一张表有几十万条记录，每次同步都要比较全部的行，比较麻烦。但是，如果商场数据库中,用来描述商场本身信息的表肯定很小，可以采取这种方式。
\item 全表拷贝：定时清空目的数据源，将源数据源的数据全盘拷贝到目的数据源。一般用于数据量不大，实时性要求不高的场景。
这种方式，看不出价值在哪里。
\end{itemize}
\par 上面五种数据同步方式，除了第五种都需要业务表有主键。对于没有触发器和日志的一些小型数据源，如txt文本，excel文件，Aceess，则只能使用后三种方式。对于大型数据源，一般优先选择日志方式，如\textbf{ORCALE Asynchronized CDC},对于不能通过日志来实现的情况，可以考虑第1，3，4种方式。
\subsection{数据仓库}
\par \textbf{数据仓库是：面向主题的、集成的、稳定的、面向时间的数据集合。}一句简单的话，阐述了数据仓库系统的至少一半以上的任务。面向主题的、集成的、稳定的、面向时间的，这四个形容词中，最好理解的，便是面向时间的。以民航部门拥有的出行信息为例，每一天出行的旅客、目的地等信息都是不同的，这样的记录的时间性，在航空公司的业务数据库中，可能仅仅是每条记录中的一个记录时间（年月日时分秒或者其它的什么形式）的字段，但是在数据仓库中，则是不然。数据仓库中，时间是一切数据的分类的第一方法。所有的类别、来源的数据，若是在一个时间段内产生（通常以天或周为单位），都会用相同的方法做分类。分类的方式可能是表，也可能是Hive等系统中某表中的一个分区，显然目前后者是更加常用的。所以，数据仓库中往往拥有业务数据库中的数据在时间周期内的变化的全部历史。例如我国全部航班的总的起飞数量这一数据，在业务数据库中，很可能只存储了最新的数据，但是在数据仓库中，由于每日（或周或小时）都将业务数据库的数据装入数据仓库的一个周期分类中，所以，总是能够查找到每个时间周期的全部历史数据。
\par 稳定这个特性，则指的是数据仓库中的数据，一旦从数据源中存入，便不会再进行任何变化（也就是说，是只读的，而数据库总是存储最新的满足一致性的某个历史版本），只会在此基础上进行进一步的分析处理。
\par 集成这个特性也是很好理解的，在业务数据库系统中，不同的业务系统往往使用不同类型和位置的数据库，但是在数据仓库系统中，无论何种数据源，无论是access、sql server、Mysql还是Oracle，甚至是系统访问日志，都会被统一装入同一个数据仓库系统，这便是数据仓库系统的集成性了。这里，我们把装入数据仓库系统之前数据所在的位置叫做数据源，数据源可以是异构的，也就是说可以是任何形态存储的，甚至是人工录入的。
\par 数据仓库的四个特性中，“面向主题的”是比较难以理解的。很难用一两句定义来解释其中主题二字的含义。那么我们便只能以一个例子来说明：还是以航空公司为例，在航空公司的业务数据库中，更受关注的往往是你乘坐的航班的编号、你选用的航空公司、你登机的时间等等，在用户通过数据库查询时，被查询最多的，也便是这些信息。但是在数据仓库中，这些信息的重要性往往不如作为主体的用户更加重要。航空公司们往往希望通过挖掘每个用户的行为特征，来更加精准的为客户提供服务和推送广告，这里，围绕客户的信息便是一个主题。
\par 数据仓库的数据分为三个层面来叙述：数据运营层(ODS)、数据仓库层(DW)和数据产品层（Product）。数据运营层，也叫ODS层，是最接近数据源中数据的一层，数据源中的数据，经过抽取、洗净、传输，也就说传说中的ETL之后，装入本层。本层的数据，总体上大多是按照源头业务系统的分类方式而分类的。例如这一层可能包含的数据表为：客户表（包含每个客户的身份证号、姓名、住址等）、机场登机记录（包含乘机人身份证号、航班号、乘机日期、起飞城市等）、银联的刷卡信息表（包含银行卡号、刷卡地点、刷卡时间、刷卡金额等）、银行账户表（包含银行卡号、持卡人身份证号等）等等一系列原始的业务数据。这里我们可以看到，这一层面的数据还具有鲜明的业务数据库的特征，甚至还具有一定的关系数据库中的数据范式的组织形式。但是，这一层面的数据却不等同于原始数据。在源数据装入这一层时，要进行诸如去噪（例如去掉明显偏离正常水平的银行刷卡信息）、去重（例如银行账户信息、公安局人口信息中均含有人的姓名，但是只保留一份即可）、提脏（例如有的人的银行卡被盗刷，在十分钟内同时有两笔分别在中国和日本的刷卡信息，这便是脏数据）、业务提取、单位统一、消减属性（例如用于支撑前端系统工作，但是在数据挖掘中不需要的属性字段）、业务判别等多项工作。
\par 数据仓库层\textbf{(DW)}，是数据仓库的主体，在这里，从ODS层中获得的数据按照主题建立各种数据模型。例如以研究人的旅游消费为主题的数据集中，便可以结合航空公司的登机出行信息，以及银联系统的刷卡记录，进行结合分析，产生数据集。在这里，需要了解四个概念：维\textbf{(Dimension)}）、事实\textbf{(Fact)}和粒度\textbf{(Granularity)}。
\par 事实\textbf{(Fact)}数据是一切数据的基础，是针对某一特定事件的度量。以上一段中研究人的旅游消费为主题的数据集为例，这个数据集中的主体的事实数据，便是人在出行到目的地之后，在目的地城市的刷卡消费信息，这一数据由业务发生的事实产生，所以叫做事实数据。维\textbf{(Dimension)}则是事实数据的其中一个侧面，例如人的旅行的目的地，则便是旅行消费信息的一个维度。
\par 在淘宝网（天猫）中，以交易为主题建立一个数据集，那么每一笔交易的信息便构成一个事实表，每一个交易可能有几十个维度，例如商品的类目、卖家、买家、品牌等等。将全部的商品类目提取出来构成一张表，那么这张表便是这个数据集的一个维度表。在大型数据仓库中，维度表往往非常复杂。例如在淘宝（天猫）中，仅类目一个维度，便包含八十余个一级类目（行业类目）、成千上万个二，三，四级类目、以及最底层的叶子类目等信息，各个类目之间还存在着树状的关联，有的一级类目便同时是叶子类目（例如手机类目）。这些维度信息构成了庞大的围绕着事实数据的维度表系统。
\par 粒度\textbf{(Granularity)}则表示数据仓库中数据集的精细程度。粒度越高，则数据的细节越多。例如在高粒度的数据表中，会包含一个人在任何城市中的每一条的刷卡记录，而在低粒度表中，则可能只包含一个人在各个城市中的刷卡总金额。这便是粒度不同的体现。这么做，是因为大多数的分析挖掘往往仅关注低维度的数据集合，那么使用高维度的数据集进行输入便会大规模的浪费系统资源。
\par 在数据仓库层中，数据按照主题组织，按照不同的事实、维度进行组合和关联分析，构成了数据仓库中主体的数据。而最后一层数据产品层，则是数据仓库中的最上层。数据产品层使用数据仓库层的数据集，针对要输出的产品不同，而进行不同的数据开发组合。例如一个分析每个城市的旅游人员的刷卡金额的数据产品，则可以在这一层中，按照城市维度，进行各大银行刷卡信息汇总的数据计算。






